package com.itheima02_Extends.p03访问规则;

/*
不能继承的内容
    1.构造方法
        子类不能继承父类的构造器，因为(子类有自己的构造器，且构造器名与类名一致的)
    2.私有成员
        父类私有的成员(成员变量，成员方法)，子类不能直接访问,但是可以通过父类中飞私有方法间接访问。
成员变量
    1.子父类变量不同名:
	    如果子类父类中出现不重名的成员变量，这时的访问是没有影响的(根据名字判断即可)。
    2.子父类变量同名:
    	如果子类父类中出现重名的成员变量，使用子类引用指向子类对象，调用的是子类自己的变量。
成员方法
    1.子父类方法不同名：
	    如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。
    2.子父类方法同名：
    	如果子类父类中出现重名的成员方法，子类对象调用该方法的时候，优先调用子类自己的方法。
方法重写
    1.概念:子类中出现与父类（返回值类型，方法名和参数列表）一模一样的方法时，会出现覆盖效果，也称为覆写或者覆盖。
    2.使用场景:子类继承父类，觉得父类某方法不满足当前子类的需求:。则重新定义与父类相同的方法，达到对该功能的增强实现。
    3.注意事项
            方法重写是发生在父子类之间的关系；
            子类方法覆盖父类方法，必须要保证权限大于等于父类权限；
            返回值类型，方法名，参数列表完全相同。
    4.@Override
            一种注解，用于方法重写的校验。
            作用:用于检查子类要重写的方法是否满足方法重写的规则(方法名是否相同、形参列表相同)
构造方法
    1.构造方法作用:
        创建对象；
        初始化对象数据。
    2.子父类初始化过程理解:
        初始化父类成员(父类变量初始化后，才可以给子类使用)
        初始化子类成员(初始化子类中的内容)
        也就是说，子类初始化，必须先执行父类的初始化，而初始化父类需要调用父类的构造方法。
    3.实现方式:
        子类每个构造器的第一行都会默认(隐含)调用父类的无参构造器，再执行自己。
        格式:super()
    4.注意事项:
        首行:在子类的构造方法中调用父类的构造方法一定要放在子类构造方法中的第一行
        默认:所有子类的构造方法第一行都会默认一个super()调用父类的空参构造方法
        手动替代默认:如果子类的构造方法中手动调用了父类的构造方法,那么就不会自动调用父类的空参构造方法创建对象。

 */
public class Test {
    public static void main(String[] args) {
        Zi z = new Zi();

        //子父类中出现同名的成员方法,使用子类中的成员方法
        z.method();

        /*子类中定义了与父类中一模一样的方法，就是方法重写
        替换掉父类的功能，对功能进行增强实现，拓展应用范围。*/
        z.show();

    }
}

