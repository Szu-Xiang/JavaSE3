package com.itheima01_多线程安全.p02可见性问题;

/*
线程可见性
    1.概述
    	可见性，表示所有的子线程对于主内存中共享变量的变化保持可见。
    2.JMM内存模型 见《JMM内存模型》
    	java虚拟机规范中定义的一种内存模型。描述了Java程序中各种(线程共享)，以及JVM中将变量存储到内存和从内存中读取变量的底层细节。
    3.问题演示：需求:通过线程中定义的开关变量演示高并发可见性问题
    4.问题总结：主线程中高速读取的开关变量的值并没有随着其他线程的执行发生改变。
    5.问题分析 见《可见性问题分析》
    	子线程从主内存读取到数据放入其对应的工作内存,flag的值为false
    	此时main方法读取到了flag的值为false,且高速执行循环
    	子线程将flag的值更改为true
    	main函数里面的while(true)调用的是底层的代码，速度快，快到没有时间再去读取主存中的值，导致while(true)读取到的值一直是false。
同步机制解决可见性问题
    1.线程同步原理
    	当线程释放锁时，JMM会把该线程对应的工作内存中的共享变量刷新到主内存中，以确保之后的线程可以获取到最新的值。
    	当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。
    2.解决办法
    	将需要保持可见性的变量，使用同步操作包裹起来。
volatile解决可见性问题
    1.概述
    	volatile关键字，标记存在可见性问题变量，确保被修改后的数据被及时读取。
    2.格式
    	权限修饰符 volatile 数据类型  变量名;
volatile的原理及与synchronize区别
    1.volatile原理
    	读内存:当读一个 volatile 变量时，JMM 会把该线程此变量对应的本地内存置为无效。线程之后将从主内存中重新读取共享变量。
    	写内存:当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存，并通知其他本地内存原主内存中的地址无效
    2.volatile与synchronize区别
    	修饰成员不同 ：volatile修饰成员变量和类变量、同步机制用于方法和代码块
    	采用机制不同：使访问被volatile修饰的线程工作内存中该变量副本无效、同步锁机制清空工作内存
    	作用范围不同 ：volatile只解决可见性问题、锁机制解决原子性问题和可见性问题
*/
public class Test {
    public static void main(String[] args) {

    }
}